#!/usr/bin/python2.7
# -*- coding: utf-8 -*-
"""
PIh5.py: Deal with the proton imaging particle tracks found optionally in HDF5 files of >FLASH4.4

Created by Scott Feister on Wed Apr 19 19:07:25 2017
"""

import h5py
import numpy as np
import os
import scipy.signal
import matplotlib.pyplot as plt

# TODO: Add a "shuffle=True" as default, that shuffles the particles
def readh5(fn, overwrite=False, shuffle=True):
    """ Read the protons out of the PI plotfile 
    fn: full filepath to the HDF5 plotfile generated by FLASH itself
    overwrite: If true, create or overwrite the '*_PItracks.h5' file. If false (default), check to see if the modified output hdf5 file already exists, and return that if it does
    shuffle: If True, shuffle the order of particles in the list. If false, sort by order of ID number.
    """

    # Define output tracks filename
    folder, name_in = os.path.split(fn)
    name_out = os.path.splitext(name_in)[0] + '_PItracks.h5' # Output filename sans directory
    fn_out = os.path.join(folder, name_out) # Output filename with directory
    
    if not overwrite:
        if os.path.isfile(fn_out):
            print(r"Reading trakarr from secondary '*_PItracks.h5' file...")
            with h5py.File(fn_out, 'r') as f:
                trakarr = f['trakarr'][...]
                return trakarr
    
    print("Creating secondary '*_PItracks.h5' file")
    ## Load into working memory and sort by particle ID
    print("Loading HDF5 plotfile tracks into memory...")
    with h5py.File(fn, 'r') as f:
        dat = f["ProtonData"][...]
    
    print("Sorting tracks by particle ID...")
    ix_arr = np.argsort(dat[:,0], kind='mergesort') # Sort by particle ID # (index 0). Mergesort keeps the paths in order, for a given ID # # TODO: Sort in batch sizes?
    dat = dat[ix_arr, :] # Sorted array
    
    # Split into sub-arrays / tracks
    # http://stackoverflow.com/questions/19125661/find-index-where-elements-change-value-numpy
    print("Splitting tracks...")
    idarr = dat[:, 0] # Array of particle ID numbers
    splitix = np.where(idarr[:-1] != idarr[1:])[0] + 1 # Array of indices at which particle ID changes (split here)
    edgeix = np.hstack((0, splitix, len(idarr))) # Array of start and stop indices; N + 1 long, where N is number of particle tracks
    traklens = np.diff(edgeix) # Array of particle track lengths
    ntraks = len(traklens) # Number of particle tracks
    
    ## Split into a larger array with one more dimension
    tlmax = np.max(traklens)  # Max track length (number of steps); Either the max number in the arrays, or 50 steps
    trakarr = np.empty((ntraks, tlmax, dat.shape[1]))
    trakarr.fill(np.nan)
    
    for i in range(ntraks):
        trakarr[i,:min(traklens[i], tlmax),:] = dat[edgeix[i]:edgeix[i] + min(traklens[i], tlmax),:]

    if shuffle:
        print("Shuffling particle track order...")
        np.random.shuffle(trakarr) # Re-order particles randomly

    # Write your new tracks to file
    print("Writing tracks to new HDF5 file in the same folder...")    
    with h5py.File(fn_out, 'w') as f:
        f.create_dataset('trakarr', data=trakarr)
        f.create_dataset('traklens', data=traklens)
        f.create_dataset('idarr', data=idarr)

    return trakarr


def moreinfo(trakarr):
    """ Digests output of "readh5"; Returns a breakdown of particle path lengths, deflection angles, positions, velocities, and accelerations
    
    Given N particles are stored in the HDF5 file:
    Inputs:
        trakarr   NumPy array, N x step x 4, full specification of trajectories; the output of "readh5" function above
    Outputs:
        pathl     NumPy array, N x step, cumulative path length along the particle trajectory
        theta     NumPy array, N x step, particle angle relative to Z axis along trajectory
        posxyz    NumPy array, 3 x N x step, particle position along trajectory
        velxyz    NumPy array, 3 x N x step, particle velocity along trajectory
        accxyz    NumPy array, 3 x N x step, particle acceleration along trajectory
        
    """
    
    dtrakarr = np.diff(trakarr, axis=1) # Difference along the traveling axis
    dr = np.sqrt(dtrakarr[:,:,1]**2 + dtrakarr[:,:,2]**2 + dtrakarr[:,:,3]**2) # N x Steps-1 long, Path length change between steps
    pathl = np.concatenate((np.zeros((dr.shape[0],1)), np.cumsum(dr, axis=1)), axis=1) # N x Steps long, Total path length up to this step

    posxyz = np.rollaxis(trakarr[:,:,1:],2,0) # Positions along the trajectory (Component x Particle x Step#)
    velxyz = np.gradient(posxyz, axis=2) # Non-normalized velocities along the trajectories (Component x Particle x Step#)
    velxyz = velxyz / np.sqrt(np.sum(velxyz**2, axis=0)) # Normalized velocities along the trajectories, normalized to 1 (Component x Particle x Step#)

    velmag = np.sqrt(np.sum(velxyz**2, axis=0)) # This is actually always 1, in our case
    theta = np.arccos(velxyz[1]/velmag)
    
    accxyz = np.gradient(velxyz, axis=2) # Accelerations, using a normalized velocity
    accmag = np.sqrt(np.sum(accxyz**2, axis=0)) # Magnitude of acceleration, using the normalized velocity
    
    return pathl, theta, posxyz, velxyz, accxyz

if __name__ == "__main__":
    #fn = r"C:\Users\Scott\Documents\temp\subdata.hdf5"
    #fn = r"C:\Users\Scott\Documents\temp\april2017\testPItrack\0250\tdyno2016_forced_hdf5_plt_cnt_0000"
    fn = r"C:\Users\scott\Documents\temp\mar2018\Pinhole trajectories\15MeV_30ns\tdyno2016_forced_hdf5_plt_cnt_0000"
    trakarr = readh5(fn, overwrite=False)
    
    print("Getting more info...")
    pathl, theta, posxyz, velxyz, accxyz = moreinfo(trakarr)
    
    theta_rel = (theta.T - theta[:,0].T).T
    dtheta = np.gradient(theta, axis=1)
 
    print("Making plots...")
    ntplot=1000
    maxpathl = 5000.0

    #ct = pathl[:ntplot,:] > maxpathl # nan condition
    xvals = trakarr[:ntplot,:,1] # X values along trajectory
    yvals = trakarr[:ntplot,:,2]
    zvals = trakarr[:ntplot,:,3]
    lvals = pathl[:ntplot,:] # Path length values along trajectory
    #xvals[ct] = np.nan
    #yvals[ct] = np.nan
    #zvals[ct] = np.nan
    #lvals[ct] = np.nan

    # (JANKY) Extract X,Y,Z endpoints
    xend = np.zeros((xvals.shape[0])) # 1D array to hold endpoints in X
    yend = np.zeros_like(xend)
    zend = np.zeros_like(xend)
    thetend = np.zeros_like(xend)
    tof = np.zeros_like(xend) # 1D array of time of flights
    ixend = np.nanargmax(yvals,1)
    for i in range(len(ixend)):
        j = ixend[i]
        xend[i] = xvals[i, j]
        yend[i] = yvals[i, j]
        zend[i] = zvals[i, j]
        thetend[i] = theta[i, j]
        tof[i] = lvals[i, j] # TODO: Sort by tof?
    
    scl = velxyz[1,:,0] / np.sqrt(np.sum(velxyz[:,:,0]**2, axis=0)) # Adjustment for TOF; Y-component of init. velocity
    scl = scl[:ntplot]
    tofadj = tof*scl # Time of flight, adjusted for starting velocity angles

    ## 2D head-on plot of particle trajectories
    fig = plt.figure(1)
    fig.clear()
    ax = fig.add_subplot(111)
    ax.plot(yvals.T, zvals.T)
    ax.set_aspect('equal')
    ax.set_xlabel("Y")
    ax.set_ylabel("Z")
    ax.set_title("Head-on view of particle tracks")
    #ax.set_ylim(-3000, 3000)
    #ax.set_xlim(0.27, 0.29)


    ## Histogram of times of flight, maps of init and final posits
    fig = plt.figure(3)
    fig.clear()

    ax0 = fig.add_subplot(221)
    ax0.hist(tof, bins=100,range=(0.62, 0.64))
    ax0.set_xlim(0.62, 0.64)
    ax0.set_xlabel("TOF (a.u.)")
    ax0.set_ylabel("Number density (a.u.)")
    ax0.set_title("Time of flight")
    ax0.set_yscale('log')

    ax1 = fig.add_subplot(222)
    ax1.hist(tofadj, bins=100,range=(0.62, 0.64))
    ax1.set_xlim(0.62, 0.64)
    ax1.set_xlabel(r"TOF (adjusted for $\theta_i$, a.u.)")
    ax1.set_ylabel("Number density (a.u.)")
    ax1.set_title("Adjusted time of flight")
    ax1.set_yscale('log')
    
    ax2 = fig.add_subplot(223)
    ax2.hexbin(xvals[:,0], zvals[:,0], gridsize=20, extent=(-0.3,0.3,0.1,0.7))
    ax2.set_xlabel("X (init.)")
    ax2.set_ylabel("Z (init.)")
    ax2.set_aspect('equal')
    ax2.set_title("Initial positions")

    ax3 = fig.add_subplot(224)
    ax3.hexbin(xend, zend, gridsize=20, extent=(-0.3,0.3,0.1,0.7))
    ax3.set_xlabel("X (final)")
    ax3.set_ylabel("Z (final)")
    ax3.set_aspect('equal')
    ax3.set_title("Final positions")

    plt.tight_layout()

    ## Theta vs. depth for a variety of particles
    #theta_rel = scipy.signal.medfilt(theta_rel, 5)
            
    slct = (theta[:,0] < np.deg2rad(2)) # minimum radius from center value
    #slct = (np.nanmax(theta_rel[:,:], axis=0) > 0.3) # minimum x value

    fig = plt.figure(4)
    fig.clear()
    
    ax1 = fig.add_subplot(111)
    nplt = 5 # Number of particles to plot here
    nplt = min(nplt, np.sum(slct))
    ax1.plot(posxyz[1,slct,:].T[:,:nplt], np.rad2deg(theta_rel[slct,:].T[:,:nplt]) + np.arange(nplt)*0.0)
    ax1.set_title("$\Delta$Theta vs. Y depth (" + str(nplt) + " particles)")
    ax1.set_ylabel("$\Delta$Theta (degs) + offset")
    ax1.set_xlabel("Spatial Y (cm)")

    plt.tight_layout()
